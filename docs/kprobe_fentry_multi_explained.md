# Linux 内核动态追踪技术：Kprobe, Fentry 与 Kprobe Multi 深度解析

本文详细介绍了 `c-pwru` 所采用的三种 eBPF 挂载技术的底层原理、优缺点及适用场景。

---

## 1. Kprobe (Legacy/Standard) —— “基于异常的断点”

Kprobe 是 Linux 内核中最通用、历史最悠久的动态追踪机制。

### 底层原理
1.  **注册期**：当用户请求在某个地址设置 kprobe 时，内核会将该地址处的原始指令（通常是几字节）备份到一段专门的内存（Ainsn slot）中。
2.  **指令替换**：内核将目标地址的第一字节替换为断点指令（x86 上是 `int3`，指令码为 `0xCC`）。
3.  **触发异常**：当执行流到达该地址时，CPU 执行到 `int3`，触发一个 **陷阱异常 (Trap Exception)**。
4.  **上下文切换**：CPU 暂停当前任务，保存寄存器，并跳转到内核的异常处理程序（`do_int3`）。
5.  **执行 BPF**：异常处理程序识别出这是一个 kprobe 事件，随后调用与之关联的 BPF 程序。
6.  **单步跳回**：BPF 程序执行完毕后，内核会让 CPU 单步执行（Single-step）刚才备份的原始指令，然后通过调整 `IP` 寄存器跳回原函数继续执行。

### 优缺点
*   **优点**：极致的通用性，几乎可以挂载到内核中任何非内联 (non-inline) 的指令地址。
*   **缺点**：**性能开销巨大**。每次触发都会引起两次 CPU 模式切换（异常触发和单步返回），在处理高频网络包时，这种开销会显著降低系统吞吐量。

---

## 2. Fentry (BPF Trampoline) —— “原生直接跳转”

Fentry 是对 Kprobe 的重大性能改进，它利用了编译器在函数入口处预留的“坑位”。

### 底层原理
1.  **编译预留**：现代 Linux 内核在编译时通常带有 `-pg` 或 `-mfentry` 参数。这会在每个可追踪函数的开头插入 5 字节的 `nop` 指令（原本为 `ftrace` 设计）。
2.  **生成蹦床 (Trampoline)**：当你加载一个 fentry 程序时，BPF 子系统会根据目标函数的签名（参数类型和个数），动态生成一段经过高度优化的汇编代码，称为 **Trampoline (蹦床)**。
3.  **直接修改指令**：内核使用 `text_poke` 机制，将目标函数开头的 `nop` 替换为一个 `call` 指令，直接指向 Trampoline 的地址。
4.  **零异常执行**：执行流到达函数入口时，通过 `call` 直接跳转到 Trampoline。Trampoline 会负责将寄存器中的参数保存到栈上，然后直接像调用普通 C 函数一样执行 BPF 程序。执行完后，再通过 `ret` 返回原函数。

### 优缺点
*   **优点**：**性能极高**。没有 CPU 异常触发，开销几乎等同于一次普通的函数调用。
*   **缺点**：强依赖 BTF（需要解析函数签名），且 BPF 程序必须与目标函数的参数定义完全一致，因此难以实现大规模（批量）挂载。

---

## 3. Kprobe Multi —— “批量化的现代接口”

Kprobe Multi 是 Linux 5.17+ 引入的一项新技术，旨在解决大规模追踪下的性能和管理问题。

### 底层原理
1.  **基于 fprobe/ftrace**：它不再走 `perf` 系统，而是基于内核的 `fprobe` 接口。`fprobe` 又是构建在 `ftrace` 的基础设施之上的。
2.  **批量指令覆盖**：`ftrace` 已经管理了内核数万个函数的入口（即上文提到的 `nop` 坑位）。Kprobe Multi 告诉内核：“我要挂载这一千个函数”。
3.  **text_poke_batch**：内核利用批量修改技术，在极短的时间内（通常伴随一个非常短暂的 CPU 停顿）将所有目标函数的入口指令重定向到 BPF。
4.  **单一链接对象**：在内核中，只创建一个 `bpf_link` 对象来管理所有这些挂载点。这大大减少了文件描述符和内存对象的消耗。

### 优缺点
*   **优点**：
    *   **启动速度极快**：正如 `c-pwru` 实测，挂载 1700+ 探针仅需 0.5s（相比传统 kprobe 缩短了 10 倍）。
    *   **清理瞬时完成**：由于只有一个链接对象，清理时间从 130s 缩短到了 0.02s。
*   **缺点**：由于一千个函数共用同一个 BPF 入口，无法在编译时确定参数签名。必须在 BPF 代码中根据寄存器位置（Arg1..Arg5）对参数进行手动提取。

---

## 技术对比表

| 特性 | Legacy Kprobe | Fentry | Kprobe Multi |
| :--- | :--- | :--- | :--- |
| **引入版本** | 极早期 | 5.5+ | 5.17+ |
| **底层实现** | `int3` 中断 | `call` 指令覆盖 | `ftrace` / `fprobe` |
| **性能开销** | 高 (涉及异常处理) | 极低 (等同函数调用) | 低/中 |
| **挂载速度** | 慢 (逐个挂载) | 慢 | **极快 (批量)** |
| **清理速度** | 极慢 (RCU 同步) | 中 | **极快** |
| **BTF 依赖** | 无 | 强依赖 | 推荐 (用于分组) |

## 在 c-pwru 中的应用

`c-pwru` 通过 `backend_ops` 接口实现了对这三种技术的完美支持：
*   **Kprobe Multi**：作为默认首选后端（如果内核版本允许且开启了 `--all-kprobes`），提供极致的启动速度。
*   **Fentry**：用于单点、高性能的精准追踪。
*   **Kprobe**：作为万能兼容方案，确保在较老版本的内核上依然可用。
